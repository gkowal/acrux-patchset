diff -uNr linux-4.10.1-r1/arch/x86/Kconfig linux-4.10.1-r2/arch/x86/Kconfig
--- linux-4.10.1-r1/arch/x86/Kconfig	2017-02-27 10:00:41.442789021 -0300
+++ linux-4.10.1-r2/arch/x86/Kconfig	2017-02-27 10:02:41.800619177 -0300
@@ -1338,7 +1338,7 @@
 endchoice
 
 choice
-	prompt "Memory split" if EXPERT
+	prompt "Memory split"
 	default VMSPLIT_3G
 	depends on X86_32
 	---help---
@@ -1358,17 +1358,17 @@
 	  option alone!
 
 	config VMSPLIT_3G
-		bool "3G/1G user/kernel split"
+		bool "Default 896MB lowmem (3G/1G user/kernel split)"
 	config VMSPLIT_3G_OPT
 		depends on !X86_PAE
-		bool "3G/1G user/kernel split (for full 1G low memory)"
+		bool "1GB lowmem (3G/1G user/kernel split)"
 	config VMSPLIT_2G
-		bool "2G/2G user/kernel split"
+		bool "2GB lowmem (2G/2G user/kernel split)"
 	config VMSPLIT_2G_OPT
 		depends on !X86_PAE
-		bool "2G/2G user/kernel split (for full 2G low memory)"
+		bool "2GB lowmem (2G/2G user/kernel split)"
 	config VMSPLIT_1G
-		bool "1G/3G user/kernel split"
+		bool "3GB lowmem (1G/3G user/kernel split)"
 endchoice
 
 config PAGE_OFFSET
diff -uNr linux-4.10.1-r1/drivers/block/swim.c linux-4.10.1-r2/drivers/block/swim.c
--- linux-4.10.1-r1/drivers/block/swim.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/block/swim.c	2017-02-27 10:02:41.806619318 -0300
@@ -332,7 +332,7 @@
 			if (swim_readbit(base, MOTOR_ON))
 				break;
 			current->state = TASK_INTERRUPTIBLE;
-			schedule_timeout(1);
+			schedule_min_hrtimeout();
 		}
 	} else if (action == OFF) {
 		swim_action(base, MOTOR_OFF);
@@ -351,7 +351,7 @@
 		if (!swim_readbit(base, DISK_IN))
 			break;
 		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(1);
+		schedule_min_hrtimeout();
 	}
 	swim_select(base, RELAX);
 }
@@ -375,7 +375,7 @@
 	for (wait = 0; wait < HZ; wait++) {
 
 		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(1);
+		schedule_min_hrtimeout();
 
 		swim_select(base, RELAX);
 		if (!swim_readbit(base, STEP))
diff -uNr linux-4.10.1-r1/drivers/bluetooth/hci_qca.c linux-4.10.1-r2/drivers/bluetooth/hci_qca.c
--- linux-4.10.1-r1/drivers/bluetooth/hci_qca.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/bluetooth/hci_qca.c	2017-02-27 10:02:41.811619435 -0300
@@ -880,7 +880,7 @@
 	 * then host can communicate with new baudrate to controller
 	 */
 	set_current_state(TASK_UNINTERRUPTIBLE);
-	schedule_timeout(msecs_to_jiffies(BAUDRATE_SETTLE_TIMEOUT_MS));
+	schedule_msec_hrtimeout((BAUDRATE_SETTLE_TIMEOUT_MS));
 	set_current_state(TASK_INTERRUPTIBLE);
 
 	return 0;
diff -uNr linux-4.10.1-r1/drivers/char/ipmi/ipmi_msghandler.c linux-4.10.1-r2/drivers/char/ipmi/ipmi_msghandler.c
--- linux-4.10.1-r1/drivers/char/ipmi/ipmi_msghandler.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/char/ipmi/ipmi_msghandler.c	2017-02-27 10:02:41.806619318 -0300
@@ -2953,7 +2953,7 @@
 	/* Current message first, to preserve order */
 	while (intf->curr_msg && !list_empty(&intf->waiting_rcv_msgs)) {
 		/* Wait for the message to clear out. */
-		schedule_timeout(1);
+		schedule_min_hrtimeout();
 	}
 
 	/* No need for locks, the interface is down. */
diff -uNr linux-4.10.1-r1/drivers/char/ipmi/ipmi_ssif.c linux-4.10.1-r2/drivers/char/ipmi/ipmi_ssif.c
--- linux-4.10.1-r1/drivers/char/ipmi/ipmi_ssif.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/char/ipmi/ipmi_ssif.c	2017-02-27 10:02:41.807619341 -0300
@@ -1185,7 +1185,7 @@
 
 	/* make sure the driver is not looking for flags any more. */
 	while (ssif_info->ssif_state != SSIF_NORMAL)
-		schedule_timeout(1);
+		schedule_min_hrtimeout();
 
 	ssif_info->stopping = true;
 	del_timer_sync(&ssif_info->retry_timer);
diff -uNr linux-4.10.1-r1/drivers/char/snsc.c linux-4.10.1-r2/drivers/char/snsc.c
--- linux-4.10.1-r1/drivers/char/snsc.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/char/snsc.c	2017-02-27 10:02:41.811619435 -0300
@@ -198,7 +198,7 @@
 		add_wait_queue(&sd->sd_rq, &wait);
 		spin_unlock_irqrestore(&sd->sd_rlock, flags);
 
-		schedule_timeout(msecs_to_jiffies(SCDRV_TIMEOUT));
+		schedule_msec_hrtimeout((SCDRV_TIMEOUT));
 
 		remove_wait_queue(&sd->sd_rq, &wait);
 		if (signal_pending(current)) {
@@ -294,7 +294,7 @@
 		add_wait_queue(&sd->sd_wq, &wait);
 		spin_unlock_irqrestore(&sd->sd_wlock, flags);
 
-		schedule_timeout(msecs_to_jiffies(SCDRV_TIMEOUT));
+		schedule_msec_hrtimeout((SCDRV_TIMEOUT));
 
 		remove_wait_queue(&sd->sd_wq, &wait);
 		if (signal_pending(current)) {
diff -uNr linux-4.10.1-r1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c linux-4.10.1-r2/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c
--- linux-4.10.1-r1/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/gpu/drm/vmwgfx/vmwgfx_fifo.c	2017-02-27 10:02:41.807619341 -0300
@@ -235,7 +235,7 @@
 			DRM_ERROR("SVGA device lockup.\n");
 			break;
 		}
-		schedule_timeout(1);
+		schedule_min_hrtimeout();
 		if (interruptible && signal_pending(current)) {
 			ret = -ERESTARTSYS;
 			break;
diff -uNr linux-4.10.1-r1/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c linux-4.10.1-r2/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c
--- linux-4.10.1-r1/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/gpu/drm/vmwgfx/vmwgfx_irq.c	2017-02-27 10:02:41.807619341 -0300
@@ -156,7 +156,7 @@
 			break;
 		}
 		if (lazy)
-			schedule_timeout(1);
+			schedule_min_hrtimeout();
 		else if ((++count & 0x0F) == 0) {
 			/**
 			 * FIXME: Use schedule_hr_timeout here for
diff -uNr linux-4.10.1-r1/drivers/hwmon/fam15h_power.c linux-4.10.1-r2/drivers/hwmon/fam15h_power.c
--- linux-4.10.1-r1/drivers/hwmon/fam15h_power.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/hwmon/fam15h_power.c	2017-02-27 10:02:41.816619553 -0300
@@ -238,7 +238,7 @@
 		prev_ptsc[cu] = data->cpu_sw_pwr_ptsc[cu];
 	}
 
-	leftover = schedule_timeout_interruptible(msecs_to_jiffies(data->power_period));
+	leftover = schedule_msec_hrtimeout_interruptible((data->power_period));
 	if (leftover)
 		return 0;
 
diff -uNr linux-4.10.1-r1/drivers/iio/light/tsl2563.c linux-4.10.1-r2/drivers/iio/light/tsl2563.c
--- linux-4.10.1-r1/drivers/iio/light/tsl2563.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/iio/light/tsl2563.c	2017-02-27 10:02:41.816619553 -0300
@@ -282,11 +282,7 @@
 	default:
 		delay = 402;
 	}
-	/*
-	 * TODO: Make sure that we wait at least required delay but why we
-	 * have to extend it one tick more?
-	 */
-	schedule_timeout_interruptible(msecs_to_jiffies(delay) + 2);
+	schedule_msec_hrtimeout_interruptible(delay + 1);
 }
 
 static int tsl2563_adjust_gainlevel(struct tsl2563_chip *chip, u16 adc)
diff -uNr linux-4.10.1-r1/drivers/media/i2c/msp3400-driver.c linux-4.10.1-r2/drivers/media/i2c/msp3400-driver.c
--- linux-4.10.1-r1/drivers/media/i2c/msp3400-driver.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/media/i2c/msp3400-driver.c	2017-02-27 10:02:41.816619553 -0300
@@ -184,7 +184,7 @@
 			break;
 		dev_warn(&client->dev, "I/O error #%d (read 0x%02x/0x%02x)\n", err,
 		       dev, addr);
-		schedule_timeout_interruptible(msecs_to_jiffies(10));
+		schedule_msec_hrtimeout_interruptible((10));
 	}
 	if (err == 3) {
 		dev_warn(&client->dev, "resetting chip, sound will go off.\n");
@@ -225,7 +225,7 @@
 			break;
 		dev_warn(&client->dev, "I/O error #%d (write 0x%02x/0x%02x)\n", err,
 		       dev, addr);
-		schedule_timeout_interruptible(msecs_to_jiffies(10));
+		schedule_msec_hrtimeout_interruptible((10));
 	}
 	if (err == 3) {
 		dev_warn(&client->dev, "resetting chip, sound will go off.\n");
diff -uNr linux-4.10.1-r1/drivers/media/pci/cx18/cx18-gpio.c linux-4.10.1-r2/drivers/media/pci/cx18/cx18-gpio.c
--- linux-4.10.1-r1/drivers/media/pci/cx18/cx18-gpio.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/media/pci/cx18/cx18-gpio.c	2017-02-27 10:02:41.819619623 -0300
@@ -95,11 +95,11 @@
 
 	/* Assert */
 	gpio_update(cx, mask, ~active_lo);
-	schedule_timeout_uninterruptible(msecs_to_jiffies(assert_msecs));
+	schedule_msec_hrtimeout_uninterruptible((assert_msecs));
 
 	/* Deassert */
 	gpio_update(cx, mask, ~active_hi);
-	schedule_timeout_uninterruptible(msecs_to_jiffies(recovery_msecs));
+	schedule_msec_hrtimeout_uninterruptible((recovery_msecs));
 }
 
 /*
diff -uNr linux-4.10.1-r1/drivers/media/pci/ivtv/ivtv-gpio.c linux-4.10.1-r2/drivers/media/pci/ivtv/ivtv-gpio.c
--- linux-4.10.1-r1/drivers/media/pci/ivtv/ivtv-gpio.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/media/pci/ivtv/ivtv-gpio.c	2017-02-27 10:02:41.816619553 -0300
@@ -117,7 +117,7 @@
 	curout = (curout & ~0xF) | 1;
 	write_reg(curout, IVTV_REG_GPIO_OUT);
 	/* We could use something else for smaller time */
-	schedule_timeout_interruptible(msecs_to_jiffies(1));
+	schedule_msec_hrtimeout_interruptible((1));
 	curout |= 2;
 	write_reg(curout, IVTV_REG_GPIO_OUT);
 	curdir &= ~0x80;
@@ -137,11 +137,11 @@
 	curout = read_reg(IVTV_REG_GPIO_OUT);
 	curout &= ~(1 << itv->card->xceive_pin);
 	write_reg(curout, IVTV_REG_GPIO_OUT);
-	schedule_timeout_interruptible(msecs_to_jiffies(1));
+	schedule_msec_hrtimeout_interruptible((1));
 
 	curout |= 1 << itv->card->xceive_pin;
 	write_reg(curout, IVTV_REG_GPIO_OUT);
-	schedule_timeout_interruptible(msecs_to_jiffies(1));
+	schedule_msec_hrtimeout_interruptible((1));
 	return 0;
 }
 
diff -uNr linux-4.10.1-r1/drivers/media/pci/ivtv/ivtv-ioctl.c linux-4.10.1-r2/drivers/media/pci/ivtv/ivtv-ioctl.c
--- linux-4.10.1-r1/drivers/media/pci/ivtv/ivtv-ioctl.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/media/pci/ivtv/ivtv-ioctl.c	2017-02-27 10:02:41.811619435 -0300
@@ -1151,7 +1151,7 @@
 				TASK_UNINTERRUPTIBLE);
 		if ((read_reg(IVTV_REG_DEC_LINE_FIELD) >> 16) < 100)
 			break;
-		schedule_timeout(msecs_to_jiffies(25));
+		schedule_msec_hrtimeout((25));
 	}
 	finish_wait(&itv->vsync_waitq, &wait);
 	mutex_lock(&itv->serialize_lock);
diff -uNr linux-4.10.1-r1/drivers/media/pci/ivtv/ivtv-streams.c linux-4.10.1-r2/drivers/media/pci/ivtv/ivtv-streams.c
--- linux-4.10.1-r1/drivers/media/pci/ivtv/ivtv-streams.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/media/pci/ivtv/ivtv-streams.c	2017-02-27 10:02:41.811619435 -0300
@@ -834,7 +834,7 @@
 			while (!test_bit(IVTV_F_I_EOS, &itv->i_flags) &&
 				time_before(jiffies,
 					    then + msecs_to_jiffies(2000))) {
-				schedule_timeout(msecs_to_jiffies(10));
+				schedule_msec_hrtimeout((10));
 			}
 
 			/* To convert jiffies to ms, we must multiply by 1000
diff -uNr linux-4.10.1-r1/drivers/media/radio/radio-mr800.c linux-4.10.1-r2/drivers/media/radio/radio-mr800.c
--- linux-4.10.1-r1/drivers/media/radio/radio-mr800.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/media/radio/radio-mr800.c	2017-02-27 10:02:41.816619553 -0300
@@ -382,7 +382,7 @@
 			retval = -ENODATA;
 			break;
 		}
-		if (schedule_timeout_interruptible(msecs_to_jiffies(10))) {
+		if (schedule_msec_hrtimeout_interruptible((10))) {
 			retval = -ERESTARTSYS;
 			break;
 		}
diff -uNr linux-4.10.1-r1/drivers/media/radio/radio-tea5777.c linux-4.10.1-r2/drivers/media/radio/radio-tea5777.c
--- linux-4.10.1-r1/drivers/media/radio/radio-tea5777.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/media/radio/radio-tea5777.c	2017-02-27 10:02:41.816619553 -0300
@@ -249,7 +249,7 @@
 	}
 
 	if (wait) {
-		if (schedule_timeout_interruptible(msecs_to_jiffies(wait)))
+		if (schedule_msec_hrtimeout_interruptible((wait)))
 			return -ERESTARTSYS;
 	}
 
diff -uNr linux-4.10.1-r1/drivers/media/radio/tea575x.c linux-4.10.1-r2/drivers/media/radio/tea575x.c
--- linux-4.10.1-r1/drivers/media/radio/tea575x.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/media/radio/tea575x.c	2017-02-27 10:02:41.816619553 -0300
@@ -416,7 +416,7 @@
 	for (;;) {
 		if (time_after(jiffies, timeout))
 			break;
-		if (schedule_timeout_interruptible(msecs_to_jiffies(10))) {
+		if (schedule_msec_hrtimeout_interruptible((10))) {
 			/* some signal arrived, stop search */
 			tea->val &= ~TEA575X_BIT_SEARCH;
 			snd_tea575x_set_freq(tea);
diff -uNr linux-4.10.1-r1/drivers/mfd/ucb1x00-core.c linux-4.10.1-r2/drivers/mfd/ucb1x00-core.c
--- linux-4.10.1-r1/drivers/mfd/ucb1x00-core.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/mfd/ucb1x00-core.c	2017-02-27 10:02:41.807619341 -0300
@@ -253,7 +253,7 @@
 			break;
 		/* yield to other processes */
 		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(1);
+		schedule_min_hrtimeout();
 	}
 
 	return UCB_ADC_DAT(val);
diff -uNr linux-4.10.1-r1/drivers/misc/panel.c linux-4.10.1-r2/drivers/misc/panel.c
--- linux-4.10.1-r1/drivers/misc/panel.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/misc/panel.c	2017-02-27 10:02:41.816619553 -0300
@@ -760,7 +760,7 @@
 	if (in_interrupt())
 		mdelay(ms);
 	else
-		schedule_timeout_interruptible(msecs_to_jiffies(ms));
+		schedule_msec_hrtimeout_interruptible((ms));
 }
 
 /*
diff -uNr linux-4.10.1-r1/drivers/misc/sgi-xp/xpc_channel.c linux-4.10.1-r2/drivers/misc/sgi-xp/xpc_channel.c
--- linux-4.10.1-r1/drivers/misc/sgi-xp/xpc_channel.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/misc/sgi-xp/xpc_channel.c	2017-02-27 10:02:41.807619341 -0300
@@ -837,7 +837,7 @@
 
 	atomic_inc(&ch->n_on_msg_allocate_wq);
 	prepare_to_wait(&ch->msg_allocate_wq, &wait, TASK_INTERRUPTIBLE);
-	ret = schedule_timeout(1);
+	ret = schedule_min_hrtimeout();
 	finish_wait(&ch->msg_allocate_wq, &wait);
 	atomic_dec(&ch->n_on_msg_allocate_wq);
 
diff -uNr linux-4.10.1-r1/drivers/net/caif/caif_hsi.c linux-4.10.1-r2/drivers/net/caif/caif_hsi.c
--- linux-4.10.1-r1/drivers/net/caif/caif_hsi.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/net/caif/caif_hsi.c	2017-02-27 10:02:41.807619341 -0300
@@ -944,7 +944,7 @@
 			break;
 
 		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(1);
+		schedule_min_hrtimeout();
 		retry--;
 	}
 
diff -uNr linux-4.10.1-r1/drivers/net/can/usb/peak_usb/pcan_usb.c linux-4.10.1-r2/drivers/net/can/usb/peak_usb/pcan_usb.c
--- linux-4.10.1-r1/drivers/net/can/usb/peak_usb/pcan_usb.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/net/can/usb/peak_usb/pcan_usb.c	2017-02-27 10:02:41.811619435 -0300
@@ -250,7 +250,7 @@
 	} else {
 		/* the PCAN-USB needs time to init */
 		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(msecs_to_jiffies(PCAN_USB_STARTUP_TIMEOUT));
+		schedule_msec_hrtimeout((PCAN_USB_STARTUP_TIMEOUT));
 	}
 
 	return err;
diff -uNr linux-4.10.1-r1/drivers/net/usb/lan78xx.c linux-4.10.1-r2/drivers/net/usb/lan78xx.c
--- linux-4.10.1-r1/drivers/net/usb/lan78xx.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/net/usb/lan78xx.c	2017-02-27 10:02:41.812619459 -0300
@@ -2544,7 +2544,7 @@
 	while (!skb_queue_empty(&dev->rxq) &&
 	       !skb_queue_empty(&dev->txq) &&
 	       !skb_queue_empty(&dev->done)) {
-		schedule_timeout(msecs_to_jiffies(UNLINK_TIMEOUT_MS));
+		schedule_msec_hrtimeout((UNLINK_TIMEOUT_MS));
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		netif_dbg(dev, ifdown, dev->net,
 			  "waited for %d urb completions\n", temp);
diff -uNr linux-4.10.1-r1/drivers/net/usb/usbnet.c linux-4.10.1-r2/drivers/net/usb/usbnet.c
--- linux-4.10.1-r1/drivers/net/usb/usbnet.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/net/usb/usbnet.c	2017-02-27 10:02:41.812619459 -0300
@@ -767,7 +767,7 @@
 	spin_lock_irqsave(&q->lock, flags);
 	while (!skb_queue_empty(q)) {
 		spin_unlock_irqrestore(&q->lock, flags);
-		schedule_timeout(msecs_to_jiffies(UNLINK_TIMEOUT_MS));
+		schedule_msec_hrtimeout((UNLINK_TIMEOUT_MS));
 		set_current_state(TASK_UNINTERRUPTIBLE);
 		spin_lock_irqsave(&q->lock, flags);
 	}
diff -uNr linux-4.10.1-r1/drivers/net/wireless/intel/ipw2x00/ipw2100.c linux-4.10.1-r2/drivers/net/wireless/intel/ipw2x00/ipw2100.c
--- linux-4.10.1-r1/drivers/net/wireless/intel/ipw2x00/ipw2100.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/net/wireless/intel/ipw2x00/ipw2100.c	2017-02-27 10:02:41.820619647 -0300
@@ -830,7 +830,7 @@
 	 * doesn't seem to have as many firmware restart cycles...
 	 *
 	 * As a test, we're sticking in a 1/100s delay here */
-	schedule_timeout_uninterruptible(msecs_to_jiffies(10));
+	schedule_msec_hrtimeout_uninterruptible((10));
 
 	return 0;
 
@@ -1281,7 +1281,7 @@
 	IPW_DEBUG_FW("Waiting for f/w initialization to complete...\n");
 	i = 5000;
 	do {
-		schedule_timeout_uninterruptible(msecs_to_jiffies(40));
+		schedule_msec_hrtimeout_uninterruptible((40));
 		/* Todo... wait for sync command ... */
 
 		read_register(priv->net_dev, IPW_REG_INTA, &inta);
diff -uNr linux-4.10.1-r1/drivers/ntb/test/ntb_perf.c linux-4.10.1-r2/drivers/ntb/test/ntb_perf.c
--- linux-4.10.1-r1/drivers/ntb/test/ntb_perf.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/ntb/test/ntb_perf.c	2017-02-27 10:02:41.807619341 -0300
@@ -308,7 +308,7 @@
 		if (unlikely((jiffies - last_sleep) > 5 * HZ)) {
 			last_sleep = jiffies;
 			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(1);
+			schedule_min_hrtimeout();
 		}
 
 		if (unlikely(kthread_should_stop()))
diff -uNr linux-4.10.1-r1/drivers/parport/ieee1284.c linux-4.10.1-r2/drivers/parport/ieee1284.c
--- linux-4.10.1-r1/drivers/parport/ieee1284.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/parport/ieee1284.c	2017-02-27 10:02:41.817619576 -0300
@@ -215,7 +215,7 @@
 			/* parport_wait_event didn't time out, but the
 			 * peripheral wasn't actually ready either.
 			 * Wait for another 10ms. */
-			schedule_timeout_interruptible(msecs_to_jiffies(10));
+			schedule_msec_hrtimeout_interruptible((10));
 		}
 	}
 
diff -uNr linux-4.10.1-r1/drivers/parport/ieee1284_ops.c linux-4.10.1-r2/drivers/parport/ieee1284_ops.c
--- linux-4.10.1-r1/drivers/parport/ieee1284_ops.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/parport/ieee1284_ops.c	2017-02-27 10:02:41.817619576 -0300
@@ -536,7 +536,7 @@
 			/* Yield the port for a while. */
 			if (count && dev->port->irq != PARPORT_IRQ_NONE) {
 				parport_release (dev);
-				schedule_timeout_interruptible(msecs_to_jiffies(40));
+				schedule_msec_hrtimeout_interruptible((40));
 				parport_claim_or_block (dev);
 			}
 			else
diff -uNr linux-4.10.1-r1/drivers/platform/x86/intel_ips.c linux-4.10.1-r2/drivers/platform/x86/intel_ips.c
--- linux-4.10.1-r1/drivers/platform/x86/intel_ips.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/platform/x86/intel_ips.c	2017-02-27 10:02:41.817619576 -0300
@@ -812,7 +812,7 @@
 			ips_gpu_lower(ips);
 
 sleep:
-		schedule_timeout_interruptible(msecs_to_jiffies(IPS_ADJUST_PERIOD));
+		schedule_msec_hrtimeout_interruptible((IPS_ADJUST_PERIOD));
 	} while (!kthread_should_stop());
 
 	dev_dbg(&ips->dev->dev, "ips-adjust thread stopped\n");
@@ -991,7 +991,7 @@
 	seqno_timestamp = get_jiffies_64();
 
 	old_cpu_power = thm_readl(THM_CEC);
-	schedule_timeout_interruptible(msecs_to_jiffies(IPS_SAMPLE_PERIOD));
+	schedule_msec_hrtimeout_interruptible((IPS_SAMPLE_PERIOD));
 
 	/* Collect an initial average */
 	for (i = 0; i < IPS_SAMPLE_COUNT; i++) {
@@ -1018,7 +1018,7 @@
 			mchp_samples[i] = mchp;
 		}
 
-		schedule_timeout_interruptible(msecs_to_jiffies(IPS_SAMPLE_PERIOD));
+		schedule_msec_hrtimeout_interruptible((IPS_SAMPLE_PERIOD));
 		if (kthread_should_stop())
 			break;
 	}
@@ -1045,7 +1045,7 @@
 	 * us to reduce the sample frequency if the CPU and GPU are idle.
 	 */
 	old_cpu_power = thm_readl(THM_CEC);
-	schedule_timeout_interruptible(msecs_to_jiffies(IPS_SAMPLE_PERIOD));
+	schedule_msec_hrtimeout_interruptible((IPS_SAMPLE_PERIOD));
 	last_sample_period = IPS_SAMPLE_PERIOD;
 
 	setup_deferrable_timer_on_stack(&timer, monitor_timeout,
diff -uNr linux-4.10.1-r1/drivers/rtc/rtc-wm8350.c linux-4.10.1-r2/drivers/rtc/rtc-wm8350.c
--- linux-4.10.1-r1/drivers/rtc/rtc-wm8350.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/rtc/rtc-wm8350.c	2017-02-27 10:02:41.820619647 -0300
@@ -121,7 +121,7 @@
 	/* Wait until confirmation of stopping */
 	do {
 		rtc_ctrl = wm8350_reg_read(wm8350, WM8350_RTC_TIME_CONTROL);
-		schedule_timeout_uninterruptible(msecs_to_jiffies(1));
+		schedule_msec_hrtimeout_uninterruptible((1));
 	} while (--retries && !(rtc_ctrl & WM8350_RTC_STS));
 
 	if (!retries) {
@@ -204,7 +204,7 @@
 	/* Wait until confirmation of stopping */
 	do {
 		rtc_ctrl = wm8350_reg_read(wm8350, WM8350_RTC_TIME_CONTROL);
-		schedule_timeout_uninterruptible(msecs_to_jiffies(1));
+		schedule_msec_hrtimeout_uninterruptible((1));
 	} while (retries-- && !(rtc_ctrl & WM8350_RTC_ALMSTS));
 
 	if (!(rtc_ctrl & WM8350_RTC_ALMSTS))
@@ -227,7 +227,7 @@
 	/* Wait until confirmation */
 	do {
 		rtc_ctrl = wm8350_reg_read(wm8350, WM8350_RTC_TIME_CONTROL);
-		schedule_timeout_uninterruptible(msecs_to_jiffies(1));
+		schedule_msec_hrtimeout_uninterruptible((1));
 	} while (retries-- && rtc_ctrl & WM8350_RTC_ALMSTS);
 
 	if (rtc_ctrl & WM8350_RTC_ALMSTS)
diff -uNr linux-4.10.1-r1/drivers/scsi/fnic/fnic_scsi.c linux-4.10.1-r2/drivers/scsi/fnic/fnic_scsi.c
--- linux-4.10.1-r1/drivers/scsi/fnic/fnic_scsi.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/scsi/fnic/fnic_scsi.c	2017-02-27 10:02:41.812619459 -0300
@@ -217,7 +217,7 @@
 
 	/* wait for io cmpl */
 	while (atomic_read(&fnic->in_flight))
-		schedule_timeout(msecs_to_jiffies(1));
+		schedule_msec_hrtimeout((1));
 
 	spin_lock_irqsave(&fnic->wq_copy_lock[0], flags);
 
@@ -2201,7 +2201,7 @@
 		}
 	}
 
-	schedule_timeout(msecs_to_jiffies(2 * fnic->config.ed_tov));
+	schedule_msec_hrtimeout((2 * fnic->config.ed_tov));
 
 	/* walk again to check, if IOs are still pending in fw */
 	if (fnic_is_abts_pending(fnic, lr_sc))
diff -uNr linux-4.10.1-r1/drivers/scsi/lpfc/lpfc_scsi.c linux-4.10.1-r2/drivers/scsi/lpfc/lpfc_scsi.c
--- linux-4.10.1-r1/drivers/scsi/lpfc/lpfc_scsi.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/scsi/lpfc/lpfc_scsi.c	2017-02-27 10:02:41.821619670 -0300
@@ -5109,7 +5109,7 @@
 					tgt_id, lun_id, context);
 	later = msecs_to_jiffies(2 * vport->cfg_devloss_tmo * 1000) + jiffies;
 	while (time_after(later, jiffies) && cnt) {
-		schedule_timeout_uninterruptible(msecs_to_jiffies(20));
+		schedule_msec_hrtimeout_uninterruptible((20));
 		cnt = lpfc_sli_sum_iocb(vport, tgt_id, lun_id, context);
 	}
 	if (cnt) {
diff -uNr linux-4.10.1-r1/drivers/scsi/snic/snic_scsi.c linux-4.10.1-r2/drivers/scsi/snic/snic_scsi.c
--- linux-4.10.1-r1/drivers/scsi/snic/snic_scsi.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/scsi/snic/snic_scsi.c	2017-02-27 10:02:41.813619482 -0300
@@ -2356,7 +2356,7 @@
 
 	/* Wait for all the IOs that are entered in Qcmd */
 	while (atomic_read(&snic->ios_inflight))
-		schedule_timeout(msecs_to_jiffies(1));
+		schedule_msec_hrtimeout((1));
 
 	ret = snic_issue_hba_reset(snic, sc);
 	if (ret) {
diff -uNr linux-4.10.1-r1/drivers/staging/comedi/drivers/ni_mio_common.c linux-4.10.1-r2/drivers/staging/comedi/drivers/ni_mio_common.c
--- linux-4.10.1-r1/drivers/staging/comedi/drivers/ni_mio_common.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/staging/comedi/drivers/ni_mio_common.c	2017-02-27 10:02:41.808619365 -0300
@@ -4655,7 +4655,7 @@
 		if ((status & NI67XX_CAL_STATUS_BUSY) == 0)
 			break;
 		set_current_state(TASK_INTERRUPTIBLE);
-		if (schedule_timeout(1))
+		if (schedule_min_hrtimeout())
 			return -EIO;
 	}
 	if (i == timeout) {
diff -uNr linux-4.10.1-r1/drivers/staging/lustre/lnet/lnet/lib-eq.c linux-4.10.1-r2/drivers/staging/lustre/lnet/lnet/lib-eq.c
--- linux-4.10.1-r1/drivers/staging/lustre/lnet/lnet/lib-eq.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/staging/lustre/lnet/lnet/lib-eq.c	2017-02-27 10:02:41.813619482 -0300
@@ -328,7 +328,7 @@
 		schedule();
 	} else {
 		now = jiffies;
-		schedule_timeout(msecs_to_jiffies(tms));
+		schedule_msec_hrtimeout((tms));
 		tms -= jiffies_to_msecs(jiffies - now);
 		if (tms < 0) /* no more wait but may have new event */
 			tms = 0;
diff -uNr linux-4.10.1-r1/drivers/staging/rts5208/rtsx.c linux-4.10.1-r2/drivers/staging/rts5208/rtsx.c
--- linux-4.10.1-r1/drivers/staging/rts5208/rtsx.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/staging/rts5208/rtsx.c	2017-02-27 10:02:41.813619482 -0300
@@ -537,7 +537,7 @@
 
 	for (;;) {
 		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(msecs_to_jiffies(POLLING_INTERVAL));
+		schedule_msec_hrtimeout((POLLING_INTERVAL));
 
 		/* lock the device pointers */
 		mutex_lock(&dev->dev_mutex);
diff -uNr linux-4.10.1-r1/drivers/staging/speakup/speakup_acntpc.c linux-4.10.1-r2/drivers/staging/speakup/speakup_acntpc.c
--- linux-4.10.1-r1/drivers/staging/speakup/speakup_acntpc.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/staging/speakup/speakup_acntpc.c	2017-02-27 10:02:41.813619482 -0300
@@ -204,7 +204,7 @@
 		full_time_val = full_time->u.n.value;
 		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		if (synth_full()) {
-			schedule_timeout(msecs_to_jiffies(full_time_val));
+			schedule_msec_hrtimeout((full_time_val));
 			continue;
 		}
 		set_current_state(TASK_RUNNING);
@@ -232,7 +232,7 @@
 			jiffy_delta_val = jiffy_delta->u.n.value;
 			delay_time_val = delay_time->u.n.value;
 			spin_unlock_irqrestore(&speakup_info.spinlock, flags);
-			schedule_timeout(msecs_to_jiffies(delay_time_val));
+			schedule_msec_hrtimeout((delay_time_val));
 			jiff_max = jiffies+jiffy_delta_val;
 		}
 	}
diff -uNr linux-4.10.1-r1/drivers/staging/speakup/speakup_apollo.c linux-4.10.1-r2/drivers/staging/speakup/speakup_apollo.c
--- linux-4.10.1-r1/drivers/staging/speakup/speakup_apollo.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/staging/speakup/speakup_apollo.c	2017-02-27 10:02:41.813619482 -0300
@@ -172,7 +172,7 @@
 			outb(UART_MCR_DTR, speakup_info.port_tts + UART_MCR);
 			outb(UART_MCR_DTR | UART_MCR_RTS,
 					speakup_info.port_tts + UART_MCR);
-			schedule_timeout(msecs_to_jiffies(full_time_val));
+			schedule_msec_hrtimeout((full_time_val));
 			continue;
 		}
 		if (time_after_eq(jiffies, jiff_max) && (ch == SPACE)) {
diff -uNr linux-4.10.1-r1/drivers/staging/speakup/speakup_decext.c linux-4.10.1-r2/drivers/staging/speakup/speakup_decext.c
--- linux-4.10.1-r1/drivers/staging/speakup/speakup_decext.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/staging/speakup/speakup_decext.c	2017-02-27 10:02:41.813619482 -0300
@@ -186,7 +186,7 @@
 		if (ch == '\n')
 			ch = 0x0D;
 		if (synth_full() || !spk_serial_out(ch)) {
-			schedule_timeout(msecs_to_jiffies(delay_time_val));
+			schedule_msec_hrtimeout((delay_time_val));
 			continue;
 		}
 		set_current_state(TASK_RUNNING);
diff -uNr linux-4.10.1-r1/drivers/staging/speakup/speakup_decpc.c linux-4.10.1-r2/drivers/staging/speakup/speakup_decpc.c
--- linux-4.10.1-r1/drivers/staging/speakup/speakup_decpc.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/staging/speakup/speakup_decpc.c	2017-02-27 10:02:41.813619482 -0300
@@ -403,7 +403,7 @@
 		if (ch == '\n')
 			ch = 0x0D;
 		if (dt_sendchar(ch)) {
-			schedule_timeout(msecs_to_jiffies(delay_time_val));
+			schedule_msec_hrtimeout((delay_time_val));
 			continue;
 		}
 		set_current_state(TASK_RUNNING);
diff -uNr linux-4.10.1-r1/drivers/staging/speakup/speakup_dectlk.c linux-4.10.1-r2/drivers/staging/speakup/speakup_dectlk.c
--- linux-4.10.1-r1/drivers/staging/speakup/speakup_dectlk.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/staging/speakup/speakup_dectlk.c	2017-02-27 10:02:41.813619482 -0300
@@ -251,7 +251,7 @@
 		if (ch == '\n')
 			ch = 0x0D;
 		if (synth_full_val || !spk_serial_out(ch)) {
-			schedule_timeout(msecs_to_jiffies(delay_time_val));
+			schedule_msec_hrtimeout((delay_time_val));
 			continue;
 		}
 		set_current_state(TASK_RUNNING);
diff -uNr linux-4.10.1-r1/drivers/staging/speakup/speakup_dtlk.c linux-4.10.1-r2/drivers/staging/speakup/speakup_dtlk.c
--- linux-4.10.1-r1/drivers/staging/speakup/speakup_dtlk.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/staging/speakup/speakup_dtlk.c	2017-02-27 10:02:41.813619482 -0300
@@ -217,7 +217,7 @@
 		delay_time_val = delay_time->u.n.value;
 		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		if (synth_full()) {
-			schedule_timeout(msecs_to_jiffies(delay_time_val));
+			schedule_msec_hrtimeout((delay_time_val));
 			continue;
 		}
 		set_current_state(TASK_RUNNING);
@@ -233,7 +233,7 @@
 			delay_time_val = delay_time->u.n.value;
 			jiffy_delta_val = jiffy_delta->u.n.value;
 			spin_unlock_irqrestore(&speakup_info.spinlock, flags);
-			schedule_timeout(msecs_to_jiffies(delay_time_val));
+			schedule_msec_hrtimeout((delay_time_val));
 			jiff_max = jiffies + jiffy_delta_val;
 		}
 	}
diff -uNr linux-4.10.1-r1/drivers/staging/speakup/speakup_keypc.c linux-4.10.1-r2/drivers/staging/speakup/speakup_keypc.c
--- linux-4.10.1-r1/drivers/staging/speakup/speakup_keypc.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/staging/speakup/speakup_keypc.c	2017-02-27 10:02:41.813619482 -0300
@@ -206,7 +206,7 @@
 		full_time_val = full_time->u.n.value;
 		spin_unlock_irqrestore(&speakup_info.spinlock, flags);
 		if (synth_full()) {
-			schedule_timeout(msecs_to_jiffies(full_time_val));
+			schedule_msec_hrtimeout((full_time_val));
 			continue;
 		}
 		set_current_state(TASK_RUNNING);
@@ -239,7 +239,7 @@
 			jiffy_delta_val = jiffy_delta->u.n.value;
 			delay_time_val = delay_time->u.n.value;
 			spin_unlock_irqrestore(&speakup_info.spinlock, flags);
-			schedule_timeout(msecs_to_jiffies(delay_time_val));
+			schedule_msec_hrtimeout((delay_time_val));
 			jiff_max = jiffies+jiffy_delta_val;
 		}
 	}
diff -uNr linux-4.10.1-r1/drivers/staging/speakup/synth.c linux-4.10.1-r2/drivers/staging/speakup/synth.c
--- linux-4.10.1-r1/drivers/staging/speakup/synth.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/staging/speakup/synth.c	2017-02-27 10:02:41.813619482 -0300
@@ -120,7 +120,7 @@
 		if (ch == '\n')
 			ch = synth->procspeech;
 		if (!spk_serial_out(ch)) {
-			schedule_timeout(msecs_to_jiffies(full_time_val));
+			schedule_msec_hrtimeout((full_time_val));
 			continue;
 		}
 		if (time_after_eq(jiffies, jiff_max) && (ch == SPACE)) {
diff -uNr linux-4.10.1-r1/drivers/staging/unisys/visornic/visornic_main.c linux-4.10.1-r2/drivers/staging/unisys/visornic/visornic_main.c
--- linux-4.10.1-r1/drivers/staging/unisys/visornic/visornic_main.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/staging/unisys/visornic/visornic_main.c	2017-02-27 10:02:41.814619506 -0300
@@ -468,7 +468,7 @@
 		}
 		set_current_state(TASK_INTERRUPTIBLE);
 		spin_unlock_irqrestore(&devdata->priv_lock, flags);
-		wait += schedule_timeout(msecs_to_jiffies(10));
+		wait += schedule_msec_hrtimeout((10));
 		spin_lock_irqsave(&devdata->priv_lock, flags);
 	}
 
@@ -479,7 +479,7 @@
 		while (1) {
 			set_current_state(TASK_INTERRUPTIBLE);
 			spin_unlock_irqrestore(&devdata->priv_lock, flags);
-			schedule_timeout(msecs_to_jiffies(10));
+			schedule_msec_hrtimeout((10));
 			spin_lock_irqsave(&devdata->priv_lock, flags);
 			if (atomic_read(&devdata->usage))
 				break;
@@ -611,7 +611,7 @@
 		}
 		set_current_state(TASK_INTERRUPTIBLE);
 		spin_unlock_irqrestore(&devdata->priv_lock, flags);
-		wait += schedule_timeout(msecs_to_jiffies(10));
+		wait += schedule_msec_hrtimeout((10));
 		spin_lock_irqsave(&devdata->priv_lock, flags);
 	}
 
diff -uNr linux-4.10.1-r1/drivers/target/target_core_user.c linux-4.10.1-r2/drivers/target/target_core_user.c
--- linux-4.10.1-r1/drivers/target/target_core_user.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/target/target_core_user.c	2017-02-27 10:02:41.814619506 -0300
@@ -451,7 +451,7 @@
 
 		pr_debug("sleeping for ring space\n");
 		spin_unlock_irq(&udev->cmdr_lock);
-		ret = schedule_timeout(msecs_to_jiffies(TCMU_TIME_OUT));
+		ret = schedule_msec_hrtimeout((TCMU_TIME_OUT));
 		finish_wait(&udev->wait_cmdr, &__wait);
 		if (!ret) {
 			pr_warn("tcmu: command timed out\n");
diff -uNr linux-4.10.1-r1/drivers/video/fbdev/omap/hwa742.c linux-4.10.1-r2/drivers/video/fbdev/omap/hwa742.c
--- linux-4.10.1-r1/drivers/video/fbdev/omap/hwa742.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/video/fbdev/omap/hwa742.c	2017-02-27 10:02:41.814619506 -0300
@@ -926,7 +926,7 @@
 		if (hwa742_read_reg(HWA742_PLL_DIV_REG) & (1 << 7))
 			break;
 		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(msecs_to_jiffies(5));
+		schedule_msec_hrtimeout((5));
 	}
 	hwa742_set_update_mode(hwa742.update_mode_before_suspend);
 }
diff -uNr linux-4.10.1-r1/drivers/video/fbdev/pxafb.c linux-4.10.1-r2/drivers/video/fbdev/pxafb.c
--- linux-4.10.1-r1/drivers/video/fbdev/pxafb.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/drivers/video/fbdev/pxafb.c	2017-02-27 10:02:41.814619506 -0300
@@ -1287,7 +1287,7 @@
 		mutex_unlock(&fbi->ctrlr_lock);
 
 		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(msecs_to_jiffies(30));
+		schedule_msec_hrtimeout((30));
 	}
 
 	pr_debug("%s(): task ending\n", __func__);
diff -uNr linux-4.10.1-r1/fs/afs/vlocation.c linux-4.10.1-r2/fs/afs/vlocation.c
--- linux-4.10.1-r1/fs/afs/vlocation.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/fs/afs/vlocation.c	2017-02-27 10:02:41.808619365 -0300
@@ -129,7 +129,7 @@
 				if (vl->upd_busy_cnt > 1) {
 					/* second+ BUSY - sleep a little bit */
 					set_current_state(TASK_UNINTERRUPTIBLE);
-					schedule_timeout(1);
+					schedule_min_hrtimeout();
 				}
 				continue;
 			}
diff -uNr linux-4.10.1-r1/fs/btrfs/extent-tree.c linux-4.10.1-r2/fs/btrfs/extent-tree.c
--- linux-4.10.1-r1/fs/btrfs/extent-tree.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/fs/btrfs/extent-tree.c	2017-02-27 10:02:41.809619388 -0300
@@ -5952,7 +5952,7 @@
 
 	if (flush != BTRFS_RESERVE_NO_FLUSH &&
 	    btrfs_transaction_in_commit(fs_info))
-		schedule_timeout(1);
+		schedule_min_hrtimeout();
 
 	if (delalloc_lock)
 		mutex_lock(&BTRFS_I(inode)->delalloc_mutex);
diff -uNr linux-4.10.1-r1/fs/btrfs/inode-map.c linux-4.10.1-r2/fs/btrfs/inode-map.c
--- linux-4.10.1-r1/fs/btrfs/inode-map.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/fs/btrfs/inode-map.c	2017-02-27 10:02:41.809619388 -0300
@@ -89,7 +89,7 @@
 				btrfs_release_path(path);
 				root->ino_cache_progress = last;
 				up_read(&fs_info->commit_root_sem);
-				schedule_timeout(1);
+				schedule_min_hrtimeout();
 				goto again;
 			} else
 				continue;
diff -uNr linux-4.10.1-r1/include/linux/freezer.h linux-4.10.1-r2/include/linux/freezer.h
--- linux-4.10.1-r1/include/linux/freezer.h	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/include/linux/freezer.h	2017-02-27 10:02:41.823619717 -0300
@@ -296,6 +296,7 @@
 #define wait_event_freezekillable_unsafe(wq, condition)			\
 		wait_event_killable(wq, condition)
 
+#define pm_freezing (false)
 #endif /* !CONFIG_FREEZER */
 
 #endif	/* FREEZER_H_INCLUDED */
diff -uNr linux-4.10.1-r1/include/linux/sched.h linux-4.10.1-r2/include/linux/sched.h
--- linux-4.10.1-r1/include/linux/sched.h	2017-02-27 10:00:41.443789044 -0300
+++ linux-4.10.1-r2/include/linux/sched.h	2017-02-27 10:02:41.823619717 -0300
@@ -457,6 +457,34 @@
 extern signed long schedule_timeout_killable(signed long timeout);
 extern signed long schedule_timeout_uninterruptible(signed long timeout);
 extern signed long schedule_timeout_idle(signed long timeout);
+
+#ifdef CONFIG_HIGH_RES_TIMERS
+extern signed long schedule_msec_hrtimeout(signed long timeout);
+extern signed long schedule_min_hrtimeout(void);
+extern signed long schedule_msec_hrtimeout_interruptible(signed long timeout);
+extern signed long schedule_msec_hrtimeout_uninterruptible(signed long timeout);
+#else
+static inline signed long schedule_msec_hrtimeout(signed long timeout)
+{
+	return schedule_timeout(msecs_to_jiffies(timeout));
+}
+
+static inline signed long schedule_min_hrtimeout(void)
+{
+	return schedule_timeout(1);
+}
+
+static inline signed long schedule_msec_hrtimeout_interruptible(signed long timeout)
+{
+	return schedule_timeout_interruptible(msecs_to_jiffies(timeout));
+}
+
+static inline signed long schedule_msec_hrtimeout_uninterruptible(signed long timeout)
+{
+	return schedule_timeout_uninterruptible(msecs_to_jiffies(timeout));
+}
+#endif
+
 asmlinkage void schedule(void);
 extern void schedule_preempt_disabled(void);
 
diff -uNr linux-4.10.1-r1/kernel/Kconfig.hz linux-4.10.1-r2/kernel/Kconfig.hz
--- linux-4.10.1-r1/kernel/Kconfig.hz	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/kernel/Kconfig.hz	2017-02-27 10:02:41.828619835 -0300
@@ -4,7 +4,8 @@
 
 choice
 	prompt "Timer frequency"
-	default HZ_250
+	default HZ_100_MUQSS if SCHED_MUQSS
+	default HZ_250 if !SCHED_MUQSS
 	help
 	 Allows the configuration of the timer frequency. It is customary
 	 to have the timer interrupt run at 1000 Hz but 100 Hz may be more
@@ -16,15 +17,30 @@
 	 per second.
 
 
+	config HZ_100_MUQSS
+		bool "100 HZ" if SCHED_MUQSS
+	help
+	  100 Hz is a suitable choice in combination with MuQSS which does
+	  not rely on ticks for rescheduling interrupts, and is not Hz limited
+	  for timeouts and sleeps from both the kernel and userspace.
+	  This allows us to benefit from the lower overhead and higher
+	  throughput of fewer timer ticks.
+
 	config HZ_100
-		bool "100 HZ"
+		bool "100 HZ" if !SCHED_MUQSS
 	help
 	  100 Hz is a typical choice for servers, SMP and NUMA systems
 	  with lots of processors that may show reduced performance if
 	  too many timer interrupts are occurring.
 
+	config HZ_250_MUQSS
+		bool "250 HZ" if SCHED_MUQSS
+	help
+	 250 Hz is the default choice for the mainline scheduler but not
+	 advantageous in combination with MuQSS.
+
 	config HZ_250
-		bool "250 HZ"
+		bool "250 HZ" if !SCHED_MUQSS
 	help
 	 250 Hz is a good compromise choice allowing server performance
 	 while also showing good interactive responsiveness even
@@ -49,7 +65,9 @@
 
 config HZ
 	int
+	default 100 if HZ_100_MUQSS
 	default 100 if HZ_100
+	default 250 if HZ_250_MUQSS
 	default 250 if HZ_250
 	default 300 if HZ_300
 	default 1000 if HZ_1000
diff -uNr linux-4.10.1-r1/kernel/Kconfig.preempt linux-4.10.1-r2/kernel/Kconfig.preempt
--- linux-4.10.1-r1/kernel/Kconfig.preempt	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/kernel/Kconfig.preempt	2017-02-27 10:02:41.798619130 -0300
@@ -1,7 +1,7 @@
 
 choice
 	prompt "Preemption Model"
-	default PREEMPT_NONE
+	default PREEMPT
 
 config PREEMPT_NONE
 	bool "No Forced Preemption (Server)"
@@ -17,7 +17,7 @@
 	  latencies.
 
 config PREEMPT_VOLUNTARY
-	bool "Voluntary Kernel Preemption (Desktop)"
+	bool "Voluntary Kernel Preemption (Nothing)"
 	help
 	  This option reduces the latency of the kernel by adding more
 	  "explicit preemption points" to the kernel code. These new
@@ -31,7 +31,8 @@
 	  applications to run more 'smoothly' even when the system is
 	  under load.
 
-	  Select this if you are building a kernel for a desktop system.
+	  Select this for no system in particular (choose Preemptible
+	  instead on a desktop if you know what's good for you).
 
 config PREEMPT
 	bool "Preemptible Kernel (Low-Latency Desktop)"
diff -uNr linux-4.10.1-r1/kernel/irq/Kconfig linux-4.10.1-r2/kernel/irq/Kconfig
--- linux-4.10.1-r1/kernel/irq/Kconfig	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/kernel/irq/Kconfig	2017-02-27 10:02:41.827619812 -0300
@@ -95,6 +95,20 @@
 config IRQ_FORCED_THREADING
        bool
 
+config FORCE_IRQ_THREADING
+	bool "Make IRQ threading compulsory"
+	depends on IRQ_FORCED_THREADING
+	default y
+	---help---
+
+	  Make IRQ threading mandatory for any IRQ handlers that support it
+	  instead of being optional and requiring the threadirqs kernel
+	  parameter. Instead they can be optionally disabled with the
+	  nothreadirqs kernel parameter.
+
+	  Enable if you are building for a desktop or low latency system,
+	  otherwise say N.
+
 config SPARSE_IRQ
 	bool "Support sparse irq numbering" if MAY_HAVE_SPARSE_IRQ
 	---help---
diff -uNr linux-4.10.1-r1/kernel/irq/manage.c linux-4.10.1-r2/kernel/irq/manage.c
--- linux-4.10.1-r1/kernel/irq/manage.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/kernel/irq/manage.c	2017-02-27 10:02:41.827619812 -0300
@@ -22,7 +22,17 @@
 #include "internals.h"
 
 #ifdef CONFIG_IRQ_FORCED_THREADING
+#ifdef CONFIG_FORCE_IRQ_THREADING
+__read_mostly bool force_irqthreads = true;
+#else
 __read_mostly bool force_irqthreads;
+#endif
+static int __init setup_noforced_irqthreads(char *arg)
+{
+	force_irqthreads = false;
+	return 0;
+}
+early_param("nothreadirqs", setup_noforced_irqthreads);
 
 static int __init setup_forced_irqthreads(char *arg)
 {
diff -uNr linux-4.10.1-r1/kernel/sysctl.c linux-4.10.1-r2/kernel/sysctl.c
--- linux-4.10.1-r1/kernel/sysctl.c	2017-02-27 10:00:41.449789186 -0300
+++ linux-4.10.1-r2/kernel/sysctl.c	2017-02-27 10:02:41.825619764 -0300
@@ -133,7 +133,9 @@
 extern int sched_iso_cpu;
 extern int sched_yield_type;
 #endif
-#ifdef CONFIG_PRINTK
+extern int hrtimer_granularity_us;
+extern int hrtimeout_min_us;
+#if defined(CONFIG_PRINTK) || defined(CONFIG_SCHED_MUQSS)
 static int ten_thousand = 10000;
 #endif
 #ifdef CONFIG_PERF_EVENTS
@@ -1045,6 +1047,24 @@
 		.extra2		= &two,
 	},
 #endif
+	{
+		.procname	= "hrtimer_granularity_us",
+		.data		= &hrtimer_granularity_us,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_minmax,
+		.extra1		= &one,
+		.extra2		= &ten_thousand,
+	},
+	{
+		.procname	= "hrtimeout_min_us",
+		.data		= &hrtimeout_min_us,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &proc_dointvec_minmax,
+		.extra1		= &one,
+		.extra2		= &ten_thousand,
+	},
 #if defined(CONFIG_S390) && defined(CONFIG_SMP)
 	{
 		.procname	= "spin_retry",
diff -uNr linux-4.10.1-r1/kernel/time/clockevents.c linux-4.10.1-r2/kernel/time/clockevents.c
--- linux-4.10.1-r1/kernel/time/clockevents.c	2017-02-27 10:00:41.449789186 -0300
+++ linux-4.10.1-r2/kernel/time/clockevents.c	2017-02-27 10:02:41.825619764 -0300
@@ -198,13 +198,9 @@
 
 #ifdef CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST
 
-#ifdef CONFIG_SCHED_MUQSS
+int __read_mostly hrtimer_granularity_us = 100;
 /* Limit min_delta to 100us */
-#define MIN_DELTA_LIMIT		(NSEC_PER_SEC / 10000)
-#else
-/* Limit min_delta to a jiffie */
-#define MIN_DELTA_LIMIT		(NSEC_PER_SEC / HZ)
-#endif
+#define MIN_DELTA_LIMIT		(hrtimer_granularity_us * NSEC_PER_USEC)
 
 /**
  * clockevents_increase_min_delta - raise minimum delta of a clock event device
diff -uNr linux-4.10.1-r1/kernel/time/hrtimer.c linux-4.10.1-r2/kernel/time/hrtimer.c
--- linux-4.10.1-r1/kernel/time/hrtimer.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/kernel/time/hrtimer.c	2017-02-27 10:02:41.829619858 -0300
@@ -1796,3 +1796,117 @@
 	return schedule_hrtimeout_range(expires, 0, mode);
 }
 EXPORT_SYMBOL_GPL(schedule_hrtimeout);
+
+/*
+ * As per schedule_hrtimeout but taskes a millisecond value and returns how
+ * many milliseconds are left.
+ */
+signed long __sched schedule_msec_hrtimeout(signed long timeout)
+{
+	struct hrtimer_sleeper t;
+	int delta, jiffs;
+	ktime_t expires;
+
+	if (!timeout) {
+		__set_current_state(TASK_RUNNING);
+		return 0;
+	}
+
+	jiffs = msecs_to_jiffies(timeout);
+	/*
+	 * If regular timer resolution is adequate or hrtimer resolution is not
+	 * (yet) better than Hz, as would occur during startup, use regular
+	 * timers.
+	 */
+	if (jiffs > 4 || hrtimer_resolution >= NSEC_PER_SEC / HZ || pm_freezing)
+		return schedule_timeout(jiffs);
+
+	delta = (timeout % 1000) * NSEC_PER_MSEC;
+	expires = ktime_set(0, delta);
+
+	hrtimer_init_on_stack(&t.timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	hrtimer_set_expires_range_ns(&t.timer, expires, delta);
+
+	hrtimer_init_sleeper(&t, current);
+
+	hrtimer_start_expires(&t.timer, HRTIMER_MODE_REL);
+
+	if (likely(t.task))
+		schedule();
+
+	hrtimer_cancel(&t.timer);
+	destroy_hrtimer_on_stack(&t.timer);
+
+	__set_current_state(TASK_RUNNING);
+
+	expires = hrtimer_expires_remaining(&t.timer);
+	timeout = ktime_to_ms(expires);
+	return timeout < 0 ? 0 : timeout;
+}
+
+EXPORT_SYMBOL(schedule_msec_hrtimeout);
+
+#define USECS_PER_SEC 1000000
+extern int hrtimer_granularity_us;
+
+static inline signed long schedule_usec_hrtimeout(signed long timeout)
+{
+	struct hrtimer_sleeper t;
+	ktime_t expires;
+	int delta;
+
+	if (!timeout) {
+		__set_current_state(TASK_RUNNING);
+		return 0;
+	}
+
+	if (hrtimer_resolution >= NSEC_PER_SEC / HZ)
+		return schedule_timeout(usecs_to_jiffies(timeout));
+
+	if (timeout < hrtimer_granularity_us)
+		timeout = hrtimer_granularity_us;
+	delta = (timeout % USECS_PER_SEC) * NSEC_PER_USEC;
+	expires = ktime_set(0, delta);
+
+	hrtimer_init_on_stack(&t.timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	hrtimer_set_expires_range_ns(&t.timer, expires, delta);
+
+	hrtimer_init_sleeper(&t, current);
+
+	hrtimer_start_expires(&t.timer, HRTIMER_MODE_REL);
+
+	if (likely(t.task))
+		schedule();
+
+	hrtimer_cancel(&t.timer);
+	destroy_hrtimer_on_stack(&t.timer);
+
+	__set_current_state(TASK_RUNNING);
+
+	expires = hrtimer_expires_remaining(&t.timer);
+	timeout = ktime_to_us(expires);
+	return timeout < 0 ? 0 : timeout;
+}
+
+int __read_mostly hrtimeout_min_us = 1000;
+
+signed long __sched schedule_min_hrtimeout(void)
+{
+	return usecs_to_jiffies(schedule_usec_hrtimeout(hrtimeout_min_us));
+}
+
+EXPORT_SYMBOL(schedule_min_hrtimeout);
+
+signed long __sched schedule_msec_hrtimeout_interruptible(signed long timeout)
+{
+	__set_current_state(TASK_INTERRUPTIBLE);
+	return schedule_msec_hrtimeout(timeout);
+}
+EXPORT_SYMBOL(schedule_msec_hrtimeout_interruptible);
+
+signed long __sched schedule_msec_hrtimeout_uninterruptible(signed long timeout)
+{
+	__set_current_state(TASK_UNINTERRUPTIBLE);
+	return schedule_msec_hrtimeout(timeout);
+}
+EXPORT_SYMBOL(schedule_msec_hrtimeout_uninterruptible);
diff -uNr linux-4.10.1-r1/kernel/time/timer.c linux-4.10.1-r2/kernel/time/timer.c
--- linux-4.10.1-r1/kernel/time/timer.c	2017-02-27 10:00:41.449789186 -0300
+++ linux-4.10.1-r2/kernel/time/timer.c	2017-02-27 10:02:41.830619882 -0300
@@ -42,6 +42,7 @@
 #include <linux/sched/sysctl.h>
 #include <linux/slab.h>
 #include <linux/compat.h>
+#include <linux/freezer.h>
 
 #include <linux/uaccess.h>
 #include <asm/unistd.h>
@@ -1750,6 +1751,19 @@
 
 	expire = timeout + jiffies;
 
+#ifdef CONFIG_HIGH_RES_TIMERS
+	if (timeout == 1 && hrtimer_resolution < NSEC_PER_SEC / HZ) {
+		/*
+		 * Special case 1 as being a request for the minimum timeout
+		 * and use highres timers to timeout after 1ms to workaround
+		 * the granularity of low Hz tick timers.
+		 */
+		if (!schedule_min_hrtimeout())
+			return 0;
+		goto out_timeout;
+	}
+#endif
+
 	setup_timer_on_stack(&timer, process_timeout, (unsigned long)current);
 	__mod_timer(&timer, expire, false);
 	schedule();
@@ -1757,10 +1771,10 @@
 
 	/* Remove the timer from the object tracker */
 	destroy_timer_on_stack(&timer);
-
+out_timeout:
 	timeout = expire - jiffies;
 
- out:
+out:
 	return timeout < 0 ? 0 : timeout;
 }
 EXPORT_SYMBOL(schedule_timeout);
@@ -1881,7 +1895,19 @@
  */
 void msleep(unsigned int msecs)
 {
-	unsigned long timeout = msecs_to_jiffies(msecs) + 1;
+	int jiffs = msecs_to_jiffies(msecs);
+	unsigned long timeout;
+
+	/*
+	 * Use high resolution timers where the resolution of tick based
+	 * timers is inadequate.
+	 */
+	if (jiffs < 5 && hrtimer_resolution < NSEC_PER_SEC / HZ && !pm_freezing) {
+		while (msecs)
+			msecs = schedule_msec_hrtimeout_uninterruptible(msecs);
+		return;
+	}
+	timeout = jiffs + 1;
 
 	while (timeout)
 		timeout = schedule_timeout_uninterruptible(timeout);
@@ -1895,7 +1921,15 @@
  */
 unsigned long msleep_interruptible(unsigned int msecs)
 {
-	unsigned long timeout = msecs_to_jiffies(msecs) + 1;
+	int jiffs = msecs_to_jiffies(msecs);
+	unsigned long timeout;
+
+	if (jiffs < 5 && hrtimer_resolution < NSEC_PER_SEC / HZ && !pm_freezing) {
+		while (msecs && !signal_pending(current))
+			msecs = schedule_msec_hrtimeout_interruptible(msecs);
+		return msecs;
+	}
+	timeout = jiffs + 1;
 
 	while (timeout && !signal_pending(current))
 		timeout = schedule_timeout_interruptible(timeout);
diff -uNr linux-4.10.1-r1/net/core/pktgen.c linux-4.10.1-r2/net/core/pktgen.c
--- linux-4.10.1-r1/net/core/pktgen.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/net/core/pktgen.c	2017-02-27 10:02:41.817619576 -0300
@@ -1992,7 +1992,7 @@
 		mutex_unlock(&pktgen_thread_lock);
 		pr_debug("%s: waiting for %s to disappear....\n",
 			 __func__, ifname);
-		schedule_timeout_interruptible(msecs_to_jiffies(msec_per_try));
+		schedule_msec_hrtimeout_interruptible((msec_per_try));
 		mutex_lock(&pktgen_thread_lock);
 
 		if (++i >= max_tries) {
diff -uNr linux-4.10.1-r1/sound/pci/maestro3.c linux-4.10.1-r2/sound/pci/maestro3.c
--- linux-4.10.1-r1/sound/pci/maestro3.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/sound/pci/maestro3.c	2017-02-27 10:02:41.821619670 -0300
@@ -2016,7 +2016,7 @@
 		outw(0, io + GPIO_DATA);
 		outw(dir | GPO_PRIMARY_AC97, io + GPIO_DIRECTION);
 
-		schedule_timeout_uninterruptible(msecs_to_jiffies(delay1));
+		schedule_msec_hrtimeout_uninterruptible((delay1));
 
 		outw(GPO_PRIMARY_AC97, io + GPIO_DATA);
 		udelay(5);
@@ -2024,7 +2024,7 @@
 		outw(IO_SRAM_ENABLE | SERIAL_AC_LINK_ENABLE, io + RING_BUS_CTRL_A);
 		outw(~0, io + GPIO_MASK);
 
-		schedule_timeout_uninterruptible(msecs_to_jiffies(delay2));
+		schedule_msec_hrtimeout_uninterruptible((delay2));
 
 		if (! snd_m3_try_read_vendor(chip))
 			break;
diff -uNr linux-4.10.1-r1/sound/soc/codecs/rt5631.c linux-4.10.1-r2/sound/soc/codecs/rt5631.c
--- linux-4.10.1-r1/sound/soc/codecs/rt5631.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/sound/soc/codecs/rt5631.c	2017-02-27 10:02:41.821619670 -0300
@@ -419,7 +419,7 @@
 	hp_zc = snd_soc_read(codec, RT5631_INT_ST_IRQ_CTRL_2);
 	snd_soc_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc & 0xf7ff);
 	if (enable) {
-		schedule_timeout_uninterruptible(msecs_to_jiffies(10));
+		schedule_msec_hrtimeout_uninterruptible((10));
 		/* config one-bit depop parameter */
 		rt5631_write_index(codec, RT5631_SPK_INTL_CTRL, 0x307f);
 		snd_soc_update_bits(codec, RT5631_HP_OUT_VOL,
@@ -529,7 +529,7 @@
 	hp_zc = snd_soc_read(codec, RT5631_INT_ST_IRQ_CTRL_2);
 	snd_soc_write(codec, RT5631_INT_ST_IRQ_CTRL_2, hp_zc & 0xf7ff);
 	if (enable) {
-		schedule_timeout_uninterruptible(msecs_to_jiffies(10));
+		schedule_msec_hrtimeout_uninterruptible((10));
 
 		/* config depop sequence parameter */
 		rt5631_write_index(codec, RT5631_SPK_INTL_CTRL, 0x302f);
diff -uNr linux-4.10.1-r1/sound/soc/codecs/wm8350.c linux-4.10.1-r2/sound/soc/codecs/wm8350.c
--- linux-4.10.1-r1/sound/soc/codecs/wm8350.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/sound/soc/codecs/wm8350.c	2017-02-27 10:02:41.817619576 -0300
@@ -236,10 +236,10 @@
 		    out2->ramp == WM8350_RAMP_UP) {
 			/* delay is longer over 0dB as increases are larger */
 			if (i >= WM8350_OUTn_0dB)
-				schedule_timeout_interruptible(msecs_to_jiffies
+				schedule_msec_hrtimeout_interruptible(
 							       (2));
 			else
-				schedule_timeout_interruptible(msecs_to_jiffies
+				schedule_msec_hrtimeout_interruptible(
 							       (1));
 		} else
 			udelay(50);	/* doesn't matter if we delay longer */
@@ -1123,7 +1123,7 @@
 					 (platform->dis_out4 << 6));
 
 			/* wait for discharge */
-			schedule_timeout_interruptible(msecs_to_jiffies
+			schedule_msec_hrtimeout_interruptible(
 						       (platform->
 							cap_discharge_msecs));
 
@@ -1139,7 +1139,7 @@
 					 WM8350_VBUFEN);
 
 			/* wait for vmid */
-			schedule_timeout_interruptible(msecs_to_jiffies
+			schedule_msec_hrtimeout_interruptible(
 						       (platform->
 							vmid_charge_msecs));
 
@@ -1190,7 +1190,7 @@
 		wm8350_reg_write(wm8350, WM8350_POWER_MGMT_1, pm1);
 
 		/* wait */
-		schedule_timeout_interruptible(msecs_to_jiffies
+		schedule_msec_hrtimeout_interruptible(
 					       (platform->
 						vmid_discharge_msecs));
 
@@ -1208,7 +1208,7 @@
 				 pm1 | WM8350_OUTPUT_DRAIN_EN);
 
 		/* wait */
-		schedule_timeout_interruptible(msecs_to_jiffies
+		schedule_msec_hrtimeout_interruptible(
 					       (platform->drain_msecs));
 
 		pm1 &= ~WM8350_BIASEN;
diff -uNr linux-4.10.1-r1/sound/soc/codecs/wm8900.c linux-4.10.1-r2/sound/soc/codecs/wm8900.c
--- linux-4.10.1-r1/sound/soc/codecs/wm8900.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/sound/soc/codecs/wm8900.c	2017-02-27 10:02:41.818619600 -0300
@@ -1112,7 +1112,7 @@
 		/* Need to let things settle before stopping the clock
 		 * to ensure that restart works, see "Stopping the
 		 * master clock" in the datasheet. */
-		schedule_timeout_interruptible(msecs_to_jiffies(1));
+		schedule_msec_hrtimeout_interruptible((1));
 		snd_soc_write(codec, WM8900_REG_POWER2,
 			     WM8900_REG_POWER2_SYSCLK_ENA);
 		break;
diff -uNr linux-4.10.1-r1/sound/soc/codecs/wm9713.c linux-4.10.1-r2/sound/soc/codecs/wm9713.c
--- linux-4.10.1-r1/sound/soc/codecs/wm9713.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/sound/soc/codecs/wm9713.c	2017-02-27 10:02:41.818619600 -0300
@@ -199,7 +199,7 @@
 
 	/* Gracefully shut down the voice interface. */
 	snd_soc_update_bits(codec, AC97_HANDSET_RATE, 0x0f00, 0x0200);
-	schedule_timeout_interruptible(msecs_to_jiffies(1));
+	schedule_msec_hrtimeout_interruptible((1));
 	snd_soc_update_bits(codec, AC97_HANDSET_RATE, 0x0f00, 0x0f00);
 	snd_soc_update_bits(codec, AC97_EXTENDED_MID, 0x1000, 0x1000);
 
@@ -868,7 +868,7 @@
 	wm9713->pll_in = freq_in;
 
 	/* wait 10ms AC97 link frames for the link to stabilise */
-	schedule_timeout_interruptible(msecs_to_jiffies(10));
+	schedule_msec_hrtimeout_interruptible((10));
 	return 0;
 }
 
diff -uNr linux-4.10.1-r1/sound/soc/soc-dapm.c linux-4.10.1-r2/sound/soc/soc-dapm.c
--- linux-4.10.1-r1/sound/soc/soc-dapm.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/sound/soc/soc-dapm.c	2017-02-27 10:02:41.822619694 -0300
@@ -134,7 +134,7 @@
 static void pop_wait(u32 pop_time)
 {
 	if (pop_time)
-		schedule_timeout_uninterruptible(msecs_to_jiffies(pop_time));
+		schedule_msec_hrtimeout_uninterruptible((pop_time));
 }
 
 static void pop_dbg(struct device *dev, u32 pop_time, const char *fmt, ...)
diff -uNr linux-4.10.1-r1/sound/usb/line6/pcm.c linux-4.10.1-r2/sound/usb/line6/pcm.c
--- linux-4.10.1-r1/sound/usb/line6/pcm.c	2017-02-26 07:09:33.000000000 -0300
+++ linux-4.10.1-r2/sound/usb/line6/pcm.c	2017-02-27 10:02:41.809619388 -0300
@@ -131,7 +131,7 @@
 		if (!alive)
 			break;
 		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(1);
+		schedule_min_hrtimeout();
 	} while (--timeout > 0);
 	if (alive)
 		dev_err(line6pcm->line6->ifcdev,

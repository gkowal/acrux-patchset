diff -uNr linux-4.20-p1/Kconfig linux-4.20-p2/Kconfig
--- linux-4.20-p1/Kconfig	2018-12-23 21:55:59.000000000 -0200
+++ linux-4.20-p2/Kconfig	2018-12-31 09:55:36.464793025 -0200
@@ -30,3 +30,5 @@
 source "lib/Kconfig"
 
 source "lib/Kconfig.debug"
+
+source "distro/Kconfig"
diff -uNr linux-4.20-p1/arch/alpha/Kconfig linux-4.20-p2/arch/alpha/Kconfig
--- linux-4.20-p1/arch/alpha/Kconfig	2018-12-23 21:55:59.000000000 -0200
+++ linux-4.20-p2/arch/alpha/Kconfig	2018-12-31 09:55:36.458792882 -0200
@@ -681,6 +681,33 @@
 	default 1200 if HZ_1200
 	default 1024
 
+config ALPHA_UAC_SYSCTL
+       bool "Configure UAC policy via sysctl"
+       depends on SYSCTL
+       default y
+       ---help---
+         Configuring the UAC (unaligned access control) policy on a Linux
+         system usually involves setting a compile time define. If you say
+         Y here, you will be able to modify the UAC policy at runtime using
+         the /proc interface.
+
+         The UAC policy defines the action Linux should take when an
+         unaligned memory access occurs. The action can include printing a
+         warning message (NOPRINT), sending a signal to the offending
+         program to help developers debug their applications (SIGBUS), or
+         disabling the transparent fixing (NOFIX).
+
+         The sysctls will be initialized to the compile-time defined UAC
+         policy. You can change these manually, or with the sysctl(8)
+         userspace utility.
+
+         To disable the warning messages at runtime, you would use
+
+           echo 1 > /proc/sys/kernel/uac/noprint
+
+         This is pretty harmless. Say Y if you're not sure.
+
+
 source "drivers/pci/Kconfig"
 source "drivers/eisa/Kconfig"
 
diff -uNr linux-4.20-p1/arch/alpha/kernel/traps.c linux-4.20-p2/arch/alpha/kernel/traps.c
--- linux-4.20-p1/arch/alpha/kernel/traps.c	2018-12-23 21:55:59.000000000 -0200
+++ linux-4.20-p2/arch/alpha/kernel/traps.c	2018-12-31 09:55:36.459792905 -0200
@@ -105,6 +105,49 @@
 			   "t10", "t11", "ra", "pv", "at", "gp", "sp", "zero"};
 #endif
 
+#ifdef CONFIG_ALPHA_UAC_SYSCTL
+
+#include <linux/sysctl.h>
+
+static int enabled_noprint = 0;
+static int enabled_sigbus = 0;
+static int enabled_nofix = 0;
+
+struct ctl_table uac_table[] = {
+       {
+               .procname       = "noprint",
+               .data           = &enabled_noprint,
+               .maxlen         = sizeof (int),
+               .mode           = 0644,
+               .proc_handler = &proc_dointvec,
+       },
+       {
+               .procname       = "sigbus",
+               .data           = &enabled_sigbus,
+               .maxlen         = sizeof (int),
+               .mode           = 0644,
+               .proc_handler = &proc_dointvec,
+       },
+       {
+               .procname       = "nofix",
+               .data           = &enabled_nofix,
+               .maxlen         = sizeof (int),
+               .mode           = 0644,
+               .proc_handler = &proc_dointvec,
+       },
+       { }
+};
+
+static int __init init_uac_sysctl(void)
+{
+   /* Initialize sysctls with the #defined UAC policy */
+   enabled_noprint = (test_thread_flag (TS_UAC_NOPRINT)) ? 1 : 0;
+   enabled_sigbus = (test_thread_flag (TS_UAC_SIGBUS)) ? 1 : 0;
+   enabled_nofix = (test_thread_flag (TS_UAC_NOFIX)) ? 1 : 0;
+   return 0;
+}
+#endif
+
 static void
 dik_show_code(unsigned int *pc)
 {
@@ -732,7 +775,12 @@
 	/* Check the UAC bits to decide what the user wants us to do
 	   with the unaliged access.  */
 
+#ifndef CONFIG_ALPHA_UAC_SYSCTL
 	if (!(current_thread_info()->status & TS_UAC_NOPRINT)) {
+#else  /* CONFIG_ALPHA_UAC_SYSCTL */
+	if (!(current_thread_info()->status & TS_UAC_NOPRINT) &&
+	    !(enabled_noprint)) {
+#endif /* CONFIG_ALPHA_UAC_SYSCTL */
 		if (__ratelimit(&ratelimit)) {
 			printk("%s(%d): unaligned trap at %016lx: %p %lx %ld\n",
 			       current->comm, task_pid_nr(current),
@@ -992,3 +1040,6 @@
 	wrent(entSys, 5);
 	wrent(entDbg, 6);
 }
+#ifdef CONFIG_ALPHA_UAC_SYSCTL
+       __initcall(init_uac_sysctl);
+#endif
diff -uNr linux-4.20-p1/distro/Kconfig linux-4.20-p2/distro/Kconfig
--- linux-4.20-p1/distro/Kconfig	1969-12-31 21:00:00.000000000 -0300
+++ linux-4.20-p2/distro/Kconfig	2018-12-31 09:55:36.464793025 -0200
@@ -0,0 +1,145 @@
+menu "Gentoo Linux"
+
+config GENTOO_LINUX
+	bool "Gentoo Linux support"
+
+	default y
+
+	help
+		In order to boot Gentoo Linux a minimal set of config settings needs to
+		be enabled in the kernel; to avoid the users from having to enable them
+		manually as part of a Gentoo Linux installation or a new clean config,
+		we enable these config settings by default for convenience.
+
+		See the settings that become available for more details and fine-tuning.
+
+config GENTOO_LINUX_UDEV
+	bool "Linux dynamic and persistent device naming (userspace devfs) support"
+
+	depends on GENTOO_LINUX
+	default y if GENTOO_LINUX
+
+	select DEVTMPFS
+	select TMPFS
+	select UNIX
+
+	select MMU
+	select SHMEM
+
+	help
+		In order to boot Gentoo Linux a minimal set of config settings needs to
+		be enabled in the kernel; to avoid the users from having to enable them
+		manually as part of a Gentoo Linux installation or a new clean config,
+		we enable these config settings by default for convenience.
+
+		Currently this only selects TMPFS, DEVTMPFS and their dependencies.
+		TMPFS is enabled to maintain a tmpfs file system at /dev/shm, /run and
+		/sys/fs/cgroup; DEVTMPFS to maintain a devtmpfs file system at /dev.
+
+		Some of these are critical files that need to be available early in the
+		boot process; if not available, it causes sysfs and udev to malfunction.
+
+		To ensure Gentoo Linux boots, it is best to leave this setting enabled;
+		if you run a custom setup, you could consider whether to disable this.
+
+config GENTOO_LINUX_PORTAGE
+	bool "Select options required by Portage features"
+
+	depends on GENTOO_LINUX
+	default y if GENTOO_LINUX
+
+	select CGROUPS
+	select NAMESPACES
+	select IPC_NS
+	select NET_NS
+	select SYSVIPC
+
+	help
+		This enables options required by various Portage FEATURES.
+		Currently this selects:
+
+		CGROUPS     (required for FEATURES=cgroup)
+		IPC_NS      (required for FEATURES=ipc-sandbox)
+		NET_NS      (required for FEATURES=network-sandbox)
+		SYSVIPC     (required by IPC_NS)
+   
+
+		It is highly recommended that you leave this enabled as these FEATURES
+		are, or will soon be, enabled by default.
+
+menu "Support for init systems, system and service managers"
+	visible if GENTOO_LINUX
+
+config GENTOO_LINUX_INIT_SCRIPT
+	bool "OpenRC, runit and other script based systems and managers"
+
+	default y if GENTOO_LINUX
+
+	depends on GENTOO_LINUX
+
+	select BINFMT_SCRIPT
+
+	help
+		The init system is the first thing that loads after the kernel booted.
+
+		These config settings allow you to select which init systems to support;
+		instead of having to select all the individual settings all over the
+		place, these settings allows you to select all the settings at once.
+
+		This particular setting enables all the known requirements for OpenRC,
+		runit and similar script based systems and managers.
+
+		If you are unsure about this, it is best to leave this setting enabled.
+
+config GENTOO_LINUX_INIT_SYSTEMD
+	bool "systemd"
+
+	default n
+
+	depends on GENTOO_LINUX && GENTOO_LINUX_UDEV
+
+	select AUTOFS4_FS
+	select BLK_DEV_BSG
+	select CGROUPS
+	select CHECKPOINT_RESTORE
+	select CRYPTO_HMAC 
+	select CRYPTO_SHA256
+	select CRYPTO_USER_API_HASH
+	select DEVPTS_MULTIPLE_INSTANCES
+	select DMIID if X86_32 || X86_64 || X86
+	select EPOLL
+	select FANOTIFY
+	select FHANDLE
+	select INOTIFY_USER
+	select IPV6
+	select NET
+	select NET_NS
+	select PROC_FS
+	select SECCOMP
+	select SECCOMP_FILTER
+	select SIGNALFD
+	select SYSFS
+	select TIMERFD
+	select TMPFS_POSIX_ACL
+	select TMPFS_XATTR
+
+	select ANON_INODES
+	select BLOCK
+	select EVENTFD
+	select FSNOTIFY
+	select INET
+	select NLATTR
+
+	help
+		The init system is the first thing that loads after the kernel booted.
+
+		These config settings allow you to select which init systems to support;
+		instead of having to select all the individual settings all over the
+		place, these settings allows you to select all the settings at once.
+
+		This particular setting enables all the known requirements for systemd;
+		it also enables suggested optional settings, as the package suggests to.
+
+endmenu
+
+endmenu
diff -uNr linux-4.20-p1/kernel/sysctl.c linux-4.20-p2/kernel/sysctl.c
--- linux-4.20-p1/kernel/sysctl.c	2018-12-23 21:55:59.000000000 -0200
+++ linux-4.20-p2/kernel/sysctl.c	2018-12-31 09:55:36.460792930 -0200
@@ -157,6 +157,11 @@
 #ifdef CONFIG_INOTIFY_USER
 #include <linux/inotify.h>
 #endif
+
+#ifdef CONFIG_ALPHA_UAC_SYSCTL
+extern struct ctl_table uac_table[];
+#endif
+
 #ifdef CONFIG_SPARC
 #endif
 
@@ -1906,6 +1911,13 @@
 		.extra2		= &one,
 	},
 #endif
+#ifdef CONFIG_ALPHA_UAC_SYSCTL
+	{
+	        .procname   = "uac",
+		.mode       = 0555,
+	        .child      = uac_table,
+	 },
+#endif /* CONFIG_ALPHA_UAC_SYSCTL */
 	{ }
 };
 
